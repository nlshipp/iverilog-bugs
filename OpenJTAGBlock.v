/*******************************************************************************
* Description:
*  Verilog implementation autogenerated from OpenJTAGBlock.cyudb at 04/30/2023 16:16:03.
*
* Note:
*  This module definition will automatically be incorporated during the "HDL Generation"
*  phase of a design which uses this UDB document. 
*  Alternatively, the contents of this pane may be copied and used as a starting point
*  for a verilog component implementation. The Datapath Configuration Tool may be used
*  to adjust advanced datapath parameters (accessible from the Tools menu).
*  For more details, see the Component Author Guide and Technical Reference Manuals.
*  Both can be accessed by selecting Help -> Documentation.
*******************************************************************************/

`include "cypress.v"
/* ==================== Include Component Definitions ==================== */

// Component: CyControlReg_v1_80
`ifdef CY_BLK_DIR
`undef CY_BLK_DIR
`endif

/*
`ifdef WARP
`define CY_BLK_DIR "$CYPRESS_DIR\..\psoc\content\CyPrimitives\cyprimitives.cylib\CyControlReg_v1_80"
`include "$CYPRESS_DIR\..\psoc\content\CyPrimitives\cyprimitives.cylib\CyControlReg_v1_80\CyControlReg_v1_80.v"
`else
`define CY_BLK_DIR "C:\Program Files (x86)\Cypress\PSoC Creator\4.3\PSoC Creator\psoc\content\CyPrimitives\cyprimitives.cylib\CyControlReg_v1_80"
`include "C:\Program Files (x86)\Cypress\PSoC Creator\4.3\PSoC Creator\psoc\content\CyPrimitives\cyprimitives.cylib\CyControlReg_v1_80\CyControlReg_v1_80.v"
`endif

// Component: CyStatusReg_v1_90
`ifdef CY_BLK_DIR
`undef CY_BLK_DIR
`endif

`ifdef WARP
`define CY_BLK_DIR "$CYPRESS_DIR\..\psoc\content\CyPrimitives\cyprimitives.cylib\CyStatusReg_v1_90"
`include "$CYPRESS_DIR\..\psoc\content\CyPrimitives\cyprimitives.cylib\CyStatusReg_v1_90\CyStatusReg_v1_90.v"
`else
`define CY_BLK_DIR "C:\Program Files (x86)\Cypress\PSoC Creator\4.3\PSoC Creator\psoc\content\CyPrimitives\cyprimitives.cylib\CyStatusReg_v1_90"
`include "C:\Program Files (x86)\Cypress\PSoC Creator\4.3\PSoC Creator\psoc\content\CyPrimitives\cyprimitives.cylib\CyStatusReg_v1_90\CyStatusReg_v1_90.v"
`endif
*/
module OpenJTAGBlock (
    input wire clock,
    output wire dInReq, 
    output wire dOutReq, 
    output wire stall
);

/* ==================== Wire and Register Declarations ==================== */
localparam [3:0] State_0 = 4'b0000;
localparam [3:0] Load_A0_Cmd = 4'b0001;
localparam [3:0] PO_Cmd = 4'b0010;
localparam [3:0] SetTap = 4'b0100;
localparam [3:0] SwReset = 4'b1001;
localparam [3:0] Load_A0_Bits = 4'b0110;
localparam [3:0] RunTestIdle = 4'b1011;
localparam [3:0] Stalled = 4'b0011;
localparam [3:0] GetTapPath = 4'b1010;
localparam [3:0] Write_PI = 4'b0111;
localparam [3:0] PO_Bits = 4'b1000;
wire  [7:0] DP1_PO;
wire  [3:0] DP1_PO_CMD;
wire  [3:0] DP1_PO_ARG;
wire  [7:0] DP1_PO_rev;
wire wSetDiv;
wire wSetTap;
wire wGetTap;
wire wSwReset;
wire wHwReset;
wire wSetLsbMsb;
wire wRunShift;
wire wRunTestIdle;
wire wF0NotFull;
wire wF0Empty;
wire wF1NotEmpty;
wire wF1Full;
wire Datapath_1_d0_load;
wire Datapath_1_d1_load;
wire Datapath_1_f0_load;
wire Datapath_1_f1_load;
wire Datapath_1_route_si;
wire Datapath_1_route_ci;
wire  [2:0] Datapath_1_select;
wire Datapath_2_d0_load;
wire Datapath_2_d1_load;
wire Datapath_2_f0_load;
wire Datapath_2_f1_load;
wire Datapath_2_route_si;
wire Datapath_2_route_ci;
wire  [2:0] Datapath_2_select;
wire ctrl_0;
wire ctrl_1;
wire ctrl_2;
wire ctrl_3;
wire ctrl_4;
wire ctrl_5;
wire ctrl_6;
wire Proceed;
wire StatusReg_status0;
wire StatusReg_status1;
wire StatusReg_status2;
wire StatusReg_status3;
wire StatusReg_status4;
wire StatusReg_status5;
wire StatusReg_status6;
wire StatusReg_status7;
wire StalledCmd_status0;
wire StalledCmd_status1;
wire StalledCmd_status2;
wire StalledCmd_status3;
wire StalledCmd_status4;
wire StalledCmd_status5;
wire StalledCmd_status6;
wire StalledCmd_status7;
reg rLoadF1;
reg rStall;
reg  [3:0] SM;
reg  [3:0] rCMD;
reg  [3:0] rARG;
reg  [7:0] rBits;
reg  [7:0] rFLAGS;
reg  [3:0] rTAP;
reg  [1:0] rDP1;
reg  [3:0] rTapDst;
reg  [7:0] rTapPath;
reg  [3:0] rTapCnt;
reg rTMS;
reg rLSBMSB;

/* ==================== Assignment of Combinatorial Variables ==================== */
assign dInReq = (wF0NotFull);
assign dOutReq = (wF1NotEmpty);
assign stall = (rStall);
/* assign DP1_PO[7:0] = (8'b0); */
assign DP1_PO_CMD[3:0] = (DP1_PO[3:0]);
assign DP1_PO_ARG[3:0] = (DP1_PO[7:4]);
assign DP1_PO_rev[7:0] = ({DP1_PO[0], DP1_PO[1], DP1_PO[2], DP1_PO[3], DP1_PO[4], DP1_PO[5], DP1_PO[6], DP1_PO[7]});
assign wSetDiv = (DP1_PO[3:0] == 0);
assign wSetTap = (DP1_PO[3:0] == 1);
assign wGetTap = (DP1_PO[3:0] == 2);
assign wSwReset = (DP1_PO[3:0] == 3);
assign wHwReset = (DP1_PO[3:0] == 4);
assign wSetLsbMsb = (DP1_PO[3:0] == 5);
assign wRunShift = (DP1_PO[3:0] == 6);
assign wRunTestIdle = (DP1_PO[3:0] == 7);
assign Datapath_1_d0_load = (1'b0);
assign Datapath_1_d1_load = (1'b0);
assign Datapath_1_f0_load = (1'b0);
assign Datapath_1_f1_load = (rLoadF1);
assign Datapath_1_route_si = (1'b0);
assign Datapath_1_route_ci = (1'b0);
assign Datapath_1_select[0] = (rDP1[0]);
assign Datapath_1_select[1] = (rDP1[1]);
assign Datapath_1_select[2] = (1'b0);
assign Datapath_2_d0_load = (1'b0);
assign Datapath_2_d1_load = (1'b0);
assign Datapath_2_f0_load = (1'b0);
assign Datapath_2_f1_load = (rLoadF1);
assign Datapath_2_route_si = (1'b0);
assign Datapath_2_route_ci = (1'b0);
assign Datapath_2_select[0] = (1'b0);
assign Datapath_2_select[1] = (1'b0);
assign Datapath_2_select[2] = (1'b0);
assign StatusReg_status0 = (rTAP[0]);
assign StatusReg_status1 = (rTAP[1]);
assign StatusReg_status2 = (rTAP[2]);
assign StatusReg_status3 = (rTAP[3]);
assign StatusReg_status4 = (wF0NotFull);
assign StatusReg_status5 = (wF1NotEmpty);
assign StatusReg_status6 = (1'b0);
assign StatusReg_status7 = (rStall);
assign StalledCmd_status0 = (rCMD[0]);
assign StalledCmd_status1 = (rCMD[1]);
assign StalledCmd_status2 = (rCMD[2]);
assign StalledCmd_status3 = (rCMD[3]);
assign StalledCmd_status4 = (rARG[0]);
assign StalledCmd_status5 = (rARG[1]);
assign StalledCmd_status6 = (rARG[2]);
assign StalledCmd_status7 = (rARG[3]);

/* ==================== Datapath_1 (Width: 8) Instantiation ==================== */
parameter Datapath_1_dpconfig0 = 
{
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_ENBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM0: PI -> ALU*/
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC___F0, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM1:  Load_A0 */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM2:  PO_A0 */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM3: */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM4:   */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM5:   */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM6:   */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM7:   */
    8'hFF, 8'h00, /*CFG9:  CFG9 */
    8'hFF, 8'hFF, /*CFG11-10:  CFG11-10 */
    `SC_CMPB_A1_D1, `SC_CMPA_A0_D1, `SC_CI_B_ARITH, `SC_CI_A_ARITH, `SC_C1_MASK_DSBL, `SC_C0_MASK_DSBL, `SC_A_MASK_DSBL, `SC_DEF_SI_0, `SC_SI_B_DEFSI, `SC_SI_A_DEFSI, /*CFG13-12:  CFG13-12 */
    `SC_A0_SRC_ACC, `SC_SHIFT_SL, `SC_PI_DYN_EN, `SC_SR_SRC_REG, `SC_FIFO1_ALU, `SC_FIFO0_BUS, `SC_MSB_ENBL, `SC_MSB_BIT7, `SC_MSB_NOCHN, `SC_FB_NOCHN, `SC_CMP1_NOCHN, `SC_CMP0_NOCHN, /*CFG15-14:  CFG15-14 */
    3'h00, `SC_FIFO_SYNC__ADD, 2'h00, `SC_FIFO1_DYN_OF, `SC_FIFO0_DYN_OF, `SC_FIFO_CLK1_POS, `SC_FIFO_CLK0_POS, `SC_FIFO_CLK__DP, `SC_FIFO_CAP_AX, `SC_FIFO_LEVEL, `SC_FIFO__SYNC, `SC_EXTCRC_DSBL, `SC_WRK16CAT_DSBL /*CFG17-16:  CFG17-16 */
};
cy_psoc3_dp #(
    .cy_dpconfig( Datapath_1_dpconfig0 ),
    .d0_init( 8'b00000000 ),
    .d1_init( 8'b00000000 ),
    .a0_init( 8'b00000000 ),
    .a1_init( 8'b00000000 ))
    Datapath_1_u0(
        .reset( 1'b0 ),
        .clk( clock ),
        .cs_addr( Datapath_1_select ),
        .route_si( Datapath_1_route_si ),
        .route_ci( Datapath_1_route_ci ),
        .f0_load( Datapath_1_f0_load ),
        .f1_load( Datapath_1_f1_load ),
        .d0_load( Datapath_1_d0_load ),
        .d1_load( Datapath_1_d1_load ),
        .ce0(  ), 
        .cl0(  ), 
        .z0(  ), 
        .ff0(  ), 
        .ce1(  ), 
        .cl1(  ), 
        .z1(  ), 
        .ff1(  ), 
        .ov_msb(  ), 
        .co_msb(  ), 
        .cmsb(  ), 
        .so(  ), 
        .f0_bus_stat( wF0NotFull ), 
        .f0_blk_stat( wF0Empty ), 
        .f1_bus_stat( wF1NotEmpty ), 
        .f1_blk_stat( wF1Full ),
        .ci(1'b0),     // Carry in from previous stage
        .co(),         // Carry out to next stage
        .sir(1'b0),    // Shift in from right side
        .sor(),        // Shift out to right side
        .sil(1'b0),    // Shift in from left side
        .sol(),        // Shift out to left side
        .msbi(1'b0),   // MSB chain in
        .msbo(),       // MSB chain out
        .cei(2'b0),    // Compare equal in from prev stage
        .ceo(),        // Compare equal out to next stage
        .cli(2'b0),    // Compare less than in from prv stage
        .clo(),        // Compare less than out to next stage
        .zi(2'b0),     // Zero detect in from previous stage
        .zo(),         // Zero detect out to next stage
        .fi(2'b0),     // 0xFF detect in from previous stage
        .fo(),         // 0xFF detect out to next stage
        .capi(2'b0),   // Software capture from previous stage
        .capo(),       // Software capture to next stage
        .cfbi(1'b0),   // CRC Feedback in from previous stage
        .cfbo(),       // CRC Feedback out to next stage
        .pi(rFLAGS),     // Parallel data port
        .po(DP1_PO)      // Parallel data port
    );

/* ==================== Datapath_2 (Width: 8) Instantiation ==================== */
parameter Datapath_2_dpconfig0 = 
{
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_ENBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM0: PI -> ALU*/
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM1:   */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM2:   */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM3:   */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM4:   */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM5:   */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM6:   */
    `CS_ALU_OP_PASS, `CS_SRCA_A0, `CS_SRCB_D0, `CS_SHFT_OP_PASS, `CS_A0_SRC_NONE, `CS_A1_SRC_NONE, `CS_FEEDBACK_DSBL, `CS_CI_SEL_CFGA, `CS_SI_SEL_CFGA, `CS_CMP_SEL_CFGA,  /*CFGRAM7:   */
    8'hFF, 8'h00, /*CFG9:  CFG9 */
    8'hFF, 8'hFF, /*CFG11-10:  CFG11-10 */
    `SC_CMPB_A1_D1, `SC_CMPA_A0_D1, `SC_CI_B_ARITH, `SC_CI_A_ARITH, `SC_C1_MASK_DSBL, `SC_C0_MASK_DSBL, `SC_A_MASK_DSBL, `SC_DEF_SI_0, `SC_SI_B_DEFSI, `SC_SI_A_DEFSI, /*CFG13-12:  CFG13-12 */
    `SC_A0_SRC_ACC, `SC_SHIFT_SL, `SC_PI_DYN_EN, `SC_SR_SRC_REG, `SC_FIFO1_ALU, `SC_FIFO0_BUS, `SC_MSB_ENBL, `SC_MSB_BIT7, `SC_MSB_NOCHN, `SC_FB_NOCHN, `SC_CMP1_NOCHN, `SC_CMP0_NOCHN, /*CFG15-14:  CFG15-14 */
    3'h00, `SC_FIFO_SYNC__ADD, 2'h00, `SC_FIFO1_DYN_OF, `SC_FIFO0_DYN_OF, `SC_FIFO_CLK1_POS, `SC_FIFO_CLK0_POS, `SC_FIFO_CLK__DP, `SC_FIFO_CAP_AX, `SC_FIFO_LEVEL, `SC_FIFO__SYNC, `SC_EXTCRC_DSBL, `SC_WRK16CAT_DSBL /*CFG17-16:  CFG17-16 */
};
cy_psoc3_dp #(
    .cy_dpconfig( Datapath_2_dpconfig0 ),
    .d0_init( 8'b00000000 ),
    .d1_init( 8'b00000000 ),
    .a0_init( 8'b00000000 ),
    .a1_init( 8'b00000000 ))
    Datapath_2_u0(
        .reset( 1'b0 ),
        .clk( clock ),
        .cs_addr( Datapath_2_select ),
        .route_si( Datapath_2_route_si ),
        .route_ci( Datapath_2_route_ci ),
        .f0_load( Datapath_2_f0_load ),
        .f1_load( Datapath_2_f1_load ),
        .d0_load( Datapath_2_d0_load ),
        .d1_load( Datapath_2_d1_load ),
        .ce0(  ), 
        .cl0(  ), 
        .z0(  ), 
        .ff0(  ), 
        .ce1(  ), 
        .cl1(  ), 
        .z1(  ), 
        .ff1(  ), 
        .ov_msb(  ), 
        .co_msb(  ), 
        .cmsb(  ), 
        .so(  ), 
        .f0_bus_stat(  ), 
        .f0_blk_stat(  ), 
        .f1_bus_stat(  ), 
        .f1_blk_stat(  ),
        .ci(1'b0),     // Carry in from previous stage
        .co(),         // Carry out to next stage
        .sir(1'b0),    // Shift in from right side
        .sor(),        // Shift out to right side
        .sil(1'b0),    // Shift in from left side
        .sol(),        // Shift out to left side
        .msbi(1'b0),   // MSB chain in
        .msbo(),       // MSB chain out
        .cei(2'b0),    // Compare equal in from prev stage
        .ceo(),        // Compare equal out to next stage
        .cli(2'b0),    // Compare less than in from prv stage
        .clo(),        // Compare less than out to next stage
        .zi(2'b0),     // Zero detect in from previous stage
        .zo(),         // Zero detect out to next stage
        .fi(2'b0),     // 0xFF detect in from previous stage
        .fo(),         // 0xFF detect out to next stage
        .capi(2'b0),   // Software capture from previous stage
        .capo(),       // Software capture to next stage
        .cfbi(1'b0),   // CRC Feedback in from previous stage
        .cfbo(),       // CRC Feedback out to next stage
        .pi(rBits),     // Parallel data port
        .po()      // Parallel data port
    );

/* ==================== State Machine: SM ==================== */
always @ (posedge clock)
begin : State_0_state_logic
    case(SM)
        State_0 : 
        begin
            rLoadF1 <= (1'b0);
            rStall <= (1'b0);
            if (( wF1Full ) == 1'b1)
            begin
                SM <= State_0 ;
            end
            else if (( ~wF0Empty ) == 1'b1)
            begin
                SM <= Load_A0_Cmd ;
                rDP1[1:0] <= (2'd1) ;
            end
        end
        Load_A0_Cmd : 
        begin
            if (( 1'b1 ) == 1'b1)
            begin
                SM <= PO_Cmd ;
                rDP1[1:0] <= (2'd2) ;
            end
        end
        PO_Cmd : 
        begin
            rCMD[3:0] <= (DP1_PO_CMD);
            rARG[3:0] <= (DP1_PO_ARG);
            if (( wSetTap ) == 1'b1)
            begin
                SM <= SetTap ;
                rTapDst[3:0] <= (DP1_PO_ARG) ;
                rTapPath[7:0] <= (8'd0) ;
                rTapCnt[3:0] <= (4'd8) ;
                rTMS <= (1'b0);
            end
            else if (( wSwReset ) == 1'b1)
            begin
                SM <= SwReset ;
            end
            else if (( wRunShift ) == 1'b1)
            begin
                SM <= Load_A0_Bits ;
                rDP1 <= (2'd1) ;
            end
            else if (( wRunTestIdle ) == 1'b1)
            begin
                SM <= RunTestIdle ;
            end
            else if ((  wSetLsbMsb | wSetDiv | wGetTap | wHwReset ) == 1'b1)
            begin
                SM <= Stalled ;
                rLSBMSB <= (wSetLsbMsb ? DP1_PO_ARG[0] : rLSBMSB) ;
                rTAP[3:0] <= (wHwReset ? 4'd0 : rTAP[3:0]) ;
                rStall <= (1'b1) ;
            end
        end
        SetTap : 
        begin
            begin
                SM <= GetTapPath ;
            end
        end
        GetTapPath : 
        begin
            rBits[7:0] <= (rTapPath);
            rFLAGS[7:4] <= (4'd1 /* SEL_TMS */);
            rFLAGS[3:0] <= (4'd8 - rTapCnt);
            rDP1[1:0] <= (2'd0);
            if (( 1'b1 ) == 1'b1)
            begin
                SM <= Write_PI ;
            end
        end
        Write_PI : 
        begin
            rLoadF1 <= (1'b1);
            if (( 1'b1 ) == 1'b1)
            begin
                SM <= State_0 ;
            end
        end
        SwReset : 
        begin
            rBits[7:0] <= (8'd255);
            rFLAGS[7:4] <= (4'd1 /* SEL_TMS */);
            rFLAGS[3:0] <= (4'd5);
            rTAP[3:0] <= (4'd0);
            rDP1[1:0] <= (2'd0);
            if (( 1'b1 ) == 1'b1)
            begin
                SM <= Write_PI ;
            end
        end
        Load_A0_Bits : 
        begin
            if (( 1'b1 ) == 1'b1)
            begin
                SM <= PO_Bits ;
                rDP1 <= (2'd2 /* PO_A0 */) ;
            end
        end
        PO_Bits : 
        begin
            rBits[7:0] <= (rLSBMSB ? DP1_PO_rev[7:0] : DP1_PO[7:0]);
            rFLAGS[7:4] <= ({1'b0, 1'b1, rARG[0], 1'b0} /* PUSH_F1 + LAST_TMS */);
            rFLAGS[3:0] <= (4'd1 + rARG[3:1]);
            rTAP[3:0] <= (rARG[0] ? (rTAP + 1) : rTAP);
            rDP1[1:0] <= (2'd0);
            if (( 1'b1 ) == 1'b1)
            begin
                SM <= Write_PI ;
            end
        end
        RunTestIdle : 
        begin
            rBits[7:0] <= (8'd0);
            rFLAGS[7:4] <= (4'd1 /* SEL_TMS */);
            rFLAGS[3:0] <= (rARG[3:0] + 4'd1);
            rDP1[1:0] <= (2'd0);
            if (( 1'b1 ) == 1'b1)
            begin
                SM <= Write_PI ;
            end
        end
        Stalled : 
        begin
            if (( Proceed ) == 1'b1)
            begin
                SM <= State_0 ;
            end
        end
        default :
        begin
            SM <= State_0;
        end
    endcase
end

/* ==================== CtrlReg ==================== */
    CyControlReg_v1_80 CtrlReg (
        .control_1(ctrl_1),
        .control_2(ctrl_2),
        .control_3(ctrl_3),
        .control_0(ctrl_0),
        .control_4(ctrl_4),
        .control_5(ctrl_5),
        .control_6(ctrl_6),
        .control_7(Proceed),
        .clock(clock),
        .reset(1'b0));
    defparam CtrlReg.Bit0Mode = 1;
    defparam CtrlReg.Bit1Mode = 1;
    defparam CtrlReg.Bit2Mode = 1;
    defparam CtrlReg.Bit3Mode = 1;
    defparam CtrlReg.Bit4Mode = 1;
    defparam CtrlReg.Bit5Mode = 1;
    defparam CtrlReg.Bit6Mode = 1;
    defparam CtrlReg.Bit7Mode = 3;
    defparam CtrlReg.BitValue = 0;
    defparam CtrlReg.BusDisplay = 0;
    defparam CtrlReg.ExtrReset = 1;
    defparam CtrlReg.NumOutputs = 8;

/* ==================== StatusReg ==================== */
    CyStatusReg_v1_90 StatusReg (
        .status_0(StatusReg_status0),
        .status_1(StatusReg_status1),
        .status_2(StatusReg_status2),
        .status_3(StatusReg_status3),
        .clock(clock),
        .status_4(StatusReg_status4),
        .status_5(StatusReg_status5),
        .status_6(StatusReg_status6),
        .status_7(StatusReg_status7),
        .intr(Net_2),
        .status_bus(8'b0));
    defparam StatusReg.Bit0Mode = 0;
    defparam StatusReg.Bit1Mode = 0;
    defparam StatusReg.Bit2Mode = 0;
    defparam StatusReg.Bit3Mode = 0;
    defparam StatusReg.Bit4Mode = 0;
    defparam StatusReg.Bit5Mode = 0;
    defparam StatusReg.Bit6Mode = 0;
    defparam StatusReg.Bit7Mode = 0;
    defparam StatusReg.BusDisplay = 0;
    defparam StatusReg.Interrupt = 0;
    defparam StatusReg.MaskValue = 0;
    defparam StatusReg.NumInputs = 8;

/* ==================== StalledCmd ==================== */
    CyStatusReg_v1_90 StalledCmd (
        .status_0(StalledCmd_status0),
        .status_1(StalledCmd_status1),
        .status_2(StalledCmd_status2),
        .status_3(StalledCmd_status3),
        .clock(clock),
        .status_4(StalledCmd_status4),
        .status_5(StalledCmd_status5),
        .status_6(StalledCmd_status6),
        .status_7(StalledCmd_status7),
        .intr(Net_4),
        .status_bus(8'b0));
    defparam StalledCmd.Bit0Mode = 0;
    defparam StalledCmd.Bit1Mode = 0;
    defparam StalledCmd.Bit2Mode = 0;
    defparam StalledCmd.Bit3Mode = 0;
    defparam StalledCmd.Bit4Mode = 0;
    defparam StalledCmd.Bit5Mode = 0;
    defparam StalledCmd.Bit6Mode = 0;
    defparam StalledCmd.Bit7Mode = 0;
    defparam StalledCmd.BusDisplay = 0;
    defparam StalledCmd.Interrupt = 0;
    defparam StalledCmd.MaskValue = 0;
    defparam StalledCmd.NumInputs = 8;

endmodule

